##========================================================================
## POD DOCUMENTATION, auto-generated by podextract.perl
=pod

=cut

##========================================================================
## NAME
=pod

=head1 NAME

DiaColloDB - diachronic collocation database, top-level

=cut

##========================================================================
## SYNOPSIS
=pod

=head1 SYNOPSIS

 ##========================================================================
 ## PRELIMINARIES
 
 use DiaColloDB;
 
 ##========================================================================
 ## Constructors etc.
 
 $coldb = CLASS_OR_OBJECT->new(%args);
 
 ##========================================================================
 ## I/O: open/close
 
 $coldb_or_undef = $coldb->open($dbdir,%opts);
 @dbkeys = $coldb->dbkeys();
 $coldb_or_undef = $coldb->close();
 $bool = $coldb->opened();
 @files = $obj->diskFiles();
 
 ##========================================================================
 ## create: utils
 
 $multimap = $coldb->create_xmap($base, \%xs2i, $packfmt, $label="multimap");
 \@attrs = $coldb->attrs();
 $atitle = $CLASS_OR_OBJECT->attrTitle($attr_or_alias);
 $acbexpr = $CLASS_OR_OBJECT->attrCountBy($attr_or_alias,$matchid=0);
 $aquery_or_filter_or_undef = $CLASS_OR_OBJECT->attrQuery($attr_or_alias,$cquery);
 \@attrdata = $coldb->attrData();
 $bool = $coldb->hasAttr($attr);
 
 ##========================================================================
 ## create: from corpus
 
 $bool = $coldb->create($corpus,%opts);
 
 ##========================================================================
 ## create: union (aka merge)
 
 $coldb = $CLASS_OR_OBJECT->union(\@coldbs_or_dbdirs,%opts);
 
 ##========================================================================
 ## I/O: header
 
 @keys = $coldb->headerKeys();
 $bool = $coldb->loadHeaderData();
 
 ##========================================================================
 ## Export/Import
 
 $bool = $coldb->dbexport();
 $coldb = $coldb->dbimport();
 
 ##========================================================================
 ## Info
 
 \%info = $coldb->dbinfo();
 
 ##========================================================================
 ## Profiling: Utils
 
 $relname      = $coldb->relname($rel);
 $obj_or_undef = $coldb->relation($rel);
 \@ids         = $coldb->enumIds($enum,$req,%opts);
 
 ($dfilter,$sliceLo,$sliceHi,$dateLo,$dateHi)
               = $coldb->parseDateRequest($dateRequest='', $sliceRequest=0, $fill=0, $ddcMode=0);
 
 \%slice2xids  = $coldb->xidsByDate(\@xids, $dateRequest, $sliceRequest, $fill);
 $compiler     = $coldb->qcompiler();
 
 $cquery_or_undef = $coldb->qparse($ddc_query_string);
 $cquery          = $coldb->parseQuery([[$attr1,$val1],...], %opts) ##-- compat: ARRAY-of-ARRAYs
 
 \@aqs     = $coldb->queryAttributes($cquery,%opts);
 \@aqs     = $coldb->parseRequest($request, %opts);
 \%groupby = $coldb->groupby($groupby_request, %opts);
 $cqfilter = $coldb->query2filter($attr,$cquery,%opts);
 
 ($CQCountKeyExprs,\$CQRestrict,\@CQFilters)
            = $coldb->parseGroupBy($groupby_string_or_request,%opts);
 
 ##========================================================================
 ## Profiling: Generic
 
 $mprf = $coldb->profile($relation, %opts);
 
 ##========================================================================
 ## Profiling: Comparison (diff)
 
 $mprf = $coldb->compare($relation, %opts);
 

=cut

##========================================================================
## DESCRIPTION
=pod

=head1 DESCRIPTION

The DiaColloDB package is the top-level module
for the DiaColloDB diachronic collocation database package.
As a Perl class, a DiaColloDB object can be used to create
or query a local native database instance.

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Globals & Constants
=pod

=head2 Globals & Constants

=over 4

=item Variable: $VERSION

Package version.

=item Variable: @ISA

L<DiaColloDB|DiaColloDB> inherits from L<DiaColloDB::Client|DiaColloDB::Client>,
and provides the low-level basis for the L<DiaColloDB::Client|DiaColloDB::Client> API.

=item Variable: $PGOOD_DEFAULT

Default positive pos regex for document parsing --
don't use qr// here, since Storable doesn't like pre-compiled Regexps.
Default = C<q/^(?:N|TRUNC|VV|ADJ)/>.

=item Variable: $PBAD_DEFAULT

Default negative pos regex for document parsing.
Default = undef (none).

=item Variable: $WGOOD_DEFAULT

Default positive word regex for document parsing.
Default = C<q/[[:alpha:]]/>

=item Variable: $WBAD_DEFAULT

Default negative word regex for document parsing.
Default = q/[\.]/

=item Variable: $LGOOD_DEFAULT

Default positive lemma regex for document parsing.
Default = undef (none).

=item Variable: $LBAD_DEFAULT

Default negative lemma regex for document parsing.
Default = undef (none).

=item Variable: $ECLASS

enum class; default 'DiaColloDB::EnumFile::MMap'.
Default = 'DiaColloDB::EnumFile::MMap'.

=item Variable: $XECLASS

fixed-length enum class.
Default = 'DiaColloDB::EnumFile::FixedLen'

=item Variable: $MMCLASS

multimap class.
Default = 'DiaColloDB::MultiMapFile'

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Constructors etc.
=pod

=head2 Constructors etc.

=over 4

=item new

 $coldb = CLASS_OR_OBJECT->new(%args);

%args, object structure:

   (
    ##-- options
    dbdir => $dbdir,    ##-- database directory; REQUIRED
    flags => $fcflags,  ##-- fcntl flags or open()-style mode string; default='r'
    attrs => \@attrs,   ##-- index attributes (input as space-separated or array; compiled to array); default=undef (==>['l'])
                        ##    + each attribute can be token-attribute qw(w p l) or a document metadata attribute "doc.ATTR"
                        ##    + document "date" attribute is always indexed
    info => \%info,     ##-- additional data to return in info() method (e.g. collection, maintainer)
    bos => $bos,        ##-- special string to use for BOS, undef or empty for none (default=undef)
    eos => $eos,        ##-- special string to use for EOS, undef or empty for none (default=undef)
    pack_id => $fmt,    ##-- pack-format for IDs (default='N')
    pack_f  => $fmt,    ##-- pack-format for frequencies (default='N')
    pack_date => $fmt,  ##-- pack-format for dates (default='n')
    pack_off => $fmt,   ##-- pack-format for file offsets (default='N')
    pack_len => $len,   ##-- pack-format for string lengths (default='n')
    dmax  => $dmax,     ##-- maximum distance for collocation-frequencies and implicit ddc near() queries (default=5)
    cfmin => $cfmin,    ##-- minimum co-occurrence frequency for Cofreqs and ddc queries (default=2)
    keeptmp => $bool,   ##-- keep temporary files? (default=0)
    ##
    ##-- runtime ddc relation options
    ddcServer => "$host:$port", ##-- server for ddc relation
    ddcTimeout => $seconds,     ##-- timeout for ddc relation
    ##
    ##-- source filtering (for create())
    pgood  => $regex,   ##-- positive filter regex for part-of-speech tags
    pbad   => $regex,   ##-- negative filter regex for part-of-speech tags
    wgood  => $regex,   ##-- positive filter regex for word text
    wbad   => $regex,   ##-- negative filter regex for word text
    lgood  => $regex,   ##-- positive filter regex for lemma text
    lbad   => $regex,   ##-- negative filter regex for lemma text
    ##
    ##-- logging
    logOpen => $level,        ##-- log-level for open/close (default='info')
    logCreate => $level,      ##-- log-level for create messages (default='info')
    logCorpusFile => $level,  ##-- log-level for corpus file-parsing (default='trace')
    logCorpusFileN => $N,     ##-- log corpus file-parsing only for every N files (0 for none; default:undef ~ $corpus->size()/100)
    logExport => $level,      ##-- log-level for export messages (default='info')
    logProfile => $level,     ##-- log-level for verbose profiling messages (default='trace')
    logRequest => $level,     ##-- log-level for request-level profiling messages (default='debug')
    ##
    ##-- runtime limits
    maxExpand => $size,       ##-- maximum number of elements in query expansions (default=65535)
    ##
    ##-- attribute data
    ${a}enum => $aenum,   ##-- attribute enum: $aenum : ($dbdir/${a}_enum.*) : $astr<=>$ai : A*<=>N
                          ##    e.g.  lemmata: $lenum : ($dbdir/l_enum.*   )  : $lstr<=>$li : A*<=>N
    ${a}2x   => $a2x,     ##-- attribute multimap: $a2x : ($dbdir/${a}_2x.*) : $ai=>@xis  : N=>N*
    pack_x$a => $fmt      ##-- pack format: extract attribute-id $ai from a packed tuple-string $xs ; $ai=unpack($coldb->{"pack_x$a"},$xs)
    ##
    ##-- tuple data (+dates)
    xenum  => $xenum,     ##-- enum: tuples ($dbdir/xenum.*) : [@ais,$di]<=>$xi : N*n<=>N
    pack_x => $fmt,       ##-- symbol pack-format for $xenum : "${pack_id}[Nattrs]${pack_date}"
    xdmin => $xdmin,      ##-- minimum date
    xdmax => $xdmax,      ##-- maximum date
    ##
    ##-- tuple data (-dates) : TODO
    #tenum  => $tenum,     ##-- enum: attribute-tuples (no dates), only if $coldb->{indexAttrs}
    #pack_t => $fmt,       ##-- symbol pack-format for $tenum : "${pack_id}[Nattrs]"
    ##
    ##-- relation data
    xf    => $xf,       ##-- ug: $xi => $f($xi) : N=>N
    cof   => $cof,      ##-- cf: [$xi1,$xi2] => $f12
    ddc   => $ddc,      ##-- ddc client relation
   )

=item promote

 $cli_or_undef = $cli->promote($class,%opts);

DiaColloDB::Client method override: unsupported.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: I/O: open/close
=pod

=head2 I/O: open/close

=over 4

=item open

 $coldb_or_undef = $coldb->open($dbdir,%opts);
 $coldb_or_undef = $coldb->open();

Open the DB.

=item dbkeys

 @dbkeys = $coldb->dbkeys();

Returns list of %$coldb keys whose values are expected to be sub-objects.

=item close

 $coldb_or_undef = $coldb->close();

Close current DB, if opened.

=item opened

 $bool = $coldb->opened();

Returns truee iff db is opened.

=item diskFiles

 @files = $coldb->diskFiles();

Returns list of dist files for $coldb.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: create: utils
=pod

=head2 create: utils

=over 4

=item Variables: (%ATTR_ALIAS,%ATTR_RALIAS,%ATTR_TITLE,%ATTR_CBEXPR);

Global attribute alias hacks.

 %ATTR_ALIAS  = ($name_or_alias=>$name, ...)
 %ATTR_RALIAS = ($name=>\@aliases, ...)
 %ATTR_CBEXPR = ($name=>$ddcCountByExpr, ...)
 %ATTR_TITLE  = ($name_or_alias=>$title, ...)

=item create_xmap

 $multimap = $coldb->create_xmap($base, \%xs2i, $packfmt, $label="multimap");

Create an expansion map.

=item attrs

 \@attrs = $coldb->attrs();
 \@attrs = $coldb->attrs($attrs=$coldb-E<gt>{attrs}, $default=[]);

parse attributes in $attrs as array.

=item attrName

 $aname = $CLASS_OR_OBJECT->attrName($attr)

Returns canonical (short) attribute name for $attr.
Supports aliases in %ATTR_ALIAS = ($alias=>$name, ...).

=item attrTitle

 $atitle = $CLASS_OR_OBJECT->attrTitle($attr_or_alias);

Returns an attribute title for $attr_or_alias

=item attrCountBy

 $acbexpr = $CLASS_OR_OBJECT->attrCountBy($attr_or_alias,$matchid=0);

Returns a DDC::XS:CQCountKeyExpr object for $attr_or_alias with match-id $matchid.

=item attrQuery

 $aquery_or_filter_or_undef = $CLASS_OR_OBJECT->attrQuery($attr_or_alias,$cquery);

returns a DDC::XS::CQuery or DDC::XS::CQFilter object for condition $cquery on $attr_or_alias.

=item attrData

 \@attrdata = $coldb->attrData();
 \@attrdata = $coldb->attrData(\@attrs=$coldb->attrs)

get attribute data for \@attrs;
returns @attrdata = ({a=E<gt>$a, i=E<gt>$i, enum=E<gt>$aenum, pack_x=E<gt>$pack_xa, a2x=E<gt>$a2x, ...})

=item hasAttr

 $bool = $coldb->hasAttr($attr);

Returns true iff $coldb natively supports the attribute (or alias) $attr.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: create: from corpus
=pod

=head2 create: from corpus

=over 4

=item create

 $bool = $coldb->create($corpus,%opts);

%opts:

 $key => $val,  ##-- clobbers $coldb->{$key}

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: create: union (aka merge)
=pod

=head2 create: union (aka merge)

=over 4

=item union

 $coldb = $CLASS_OR_OBJECT->union(\@coldbs_or_dbdirs,%opts);

Populates $coldb as union over @coldbs_or_dbdirs.
Clobbers argument dbs {_union_${a}i2u}, {_union_xi2u}, {_union_argi}

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: I/O: header
=pod

=head2 I/O: header

Largely inherited from DiaColloDB::Persistent.

=over 4

=item headerKeys

 @keys = $coldb->headerKeys();

keys to save as header

=item loadHeaderData

 $bool = $coldb->loadHeaderData();
 $bool = $coldb->loadHeaderData($data)

loads header data.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Export/Import
=pod

=head2 Export/Import

=over 4

=item dbexport

 $bool = $coldb->dbexport();
 $bool = $coldb->dbexport($outdir,%opts);

$outdir defaults to "$coldb-E<gt>{dbdir}/export"
%opts:

 export_sdat => $bool,  ##-- whether to export *.sdat (stringified tuple files for debugging; default=0)
 export_cof  => $bool,  ##-- do/don't export cof.* (default=do)

=item dbimport

 $coldb = $coldb->dbimport();
 $coldb = $coldb->dbimport($txtdir,%opts)

Import ColocDB data from $txtdir

B<TODO>

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Info
=pod

=head2 Info

=over 4

=item dbinfo

 \%info = $coldb->dbinfo();

get db info

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Profiling: Utils
=pod

=head2 Profiling: Utils

=over 4

=item relname

 $relname = $coldb->relname($rel);

Returns an appropriate relation name for profile() and friends:

=over 4

=item *

returns $rel if $coldb-E<gt>{$rel} supports a profile() method

=item *

otherwise heuristically parses $relationName /xf|f?1|ug/ or /f1?2|c/

=back

=item relation

 $obj_or_undef = $coldb->relation($rel);

returns an appropriate relation-like object for profile() and friends;
really just wraps C<$coldb-E<gt>{$coldb-E<gt>relname($rel)}>.

=item enumIds

 \@ids = $coldb->enumIds($enum,$req,%opts);

parses enum IDs for $req, which is one of:

=over 4

=item *

a DDC::XS::CQTokExact, ::CQTokInfl, ::CQTokSet, ::CQTokSetInfl, or ::CQTokRegex : interpreted

=item *

an ARRAY-ref     : list of literal symbol-values

=item *

a Regexp ref     : regexp for target strings, passed to $enum-E<gt>re2i()

=item *

a string /REGEX/ : regexp for target strings, passed to $enum-E<gt>re2i()

=item *

another string   : space-, comma-, or |-separated list of literal values

=back

%opts:

 logLevel  => $logLevel, ##-- logging level (default=undef)
 logPrefix => $prefix,   ##-- logging prefix (default="enumIds(): fetch ids")

=item parseDateRequest

 ($dfilter,$sliceLo,$sliceHi,$dateLo,$dateHi) = $coldb->parseDateRequest($dateRequest='', $sliceRequest=0, $fill=0, $ddcMode=0);

low-level parsing for date (slice) requests.

=item xidsByDate

 \%slice2xids = $coldb->xidsByDate(\@xids, $dateRequest, $sliceRequest, $fill);

parse and filter \@xids by $dateRequest, $sliceRequest;
returns a HASH-ref from slice-ids to \@xids in that date-slice.
If $fill is true, returned HASH-ref has a key for each date-slice in range

=item qcompiler

 $compiler = $coldb->qcompiler();

get DDC::XS::CQueryCompiler for this object (cached in $coldb-E<gt>{_qcompiler})

=item qparse

 $cquery_or_undef = $coldb->qparse($ddc_query_string);

wraps parse in an eval {...} block and sets $coldb-E<gt>{error} on failure

=item parseQuery

 $cquery = $coldb->parseQuery([[$attr1,$val1],...], %opts) ##-- compat: ARRAY-of-ARRAYs;
 $cquery = $coldb->parseQuery(["$attr1:$val1",...], %opts) ##-- compat: ARRAY-of-requests
 $cquery = $coldb->parseQuery({$attr1=>$val1, ...}, %opts) ##-- compat: HASH
 $cquery = $coldb->parseQuery("$attr1=$val1, ...", %opts)  ##-- compat: string
 $cquery = $coldb->parseQuery($ddcQueryString, %opts)      ##-- ddc string (with shorthand ","->WITH, "&&"->WITH)

Guts for parsing user target and groupby requests;
returns a DDC::XS::CQuery object representing the request.
Index-only items "$l" are mapped to $l=*

%opts:

 warn    => $level,     ##-- log-level for unknown attributes (default: 'warn')
 logas   => $reqtype,   ##-- request type for warnings
 default => $attr,      ##-- default attribute (for query requests)
 mapand  => $bool,      ##-- map CQAnd to CQWith? (default=true unless '&&' occurs in query string)
 ddcmode => $bool,      ##-- force ddc query mode? (default=false)

=item queryAttributes

 \@aqs = $coldb->queryAttributes($cquery,%opts);

Utility for decomposing DDC queries into attribute-wise requests;
returns an ARRAY-ref [[$attr1,$val1], ...].
Each value $vali is empty or undef (all values), a CQTokSet, a CQTokExact, CQTokRegex, or CQTokAny.
Chokes on unsupported query types or filters

%opts:

 warn    => $level,     ##-- log-level for unknown attributes (default: 'warn')
 logas   => $reqtype,   ##-- request type for warnings
 default => $attr,      ##-- default attribute (for query requests)
 allowUnknown => $bool, ##-- allow unknown attributes? (default: 0)

=item parseRequest

 \@aqs = $coldb->parseRequest($request, %opts);

Guts for parsing user target and groupby requests into attribute-wise ARRAY-ref [[$attr1,$val1], ...],
used by native profiling methods.
See parseQuery() method for supported $request formats and %opts.
Wraps $coldb-E<gt>queryAttributes($coldb-E<gt>parseQuery($request,%opts)).

=item groupby

 \%groupby = $coldb->groupby($groupby_request, %opts);
 \%groupby = $coldb->groupby(\%groupby,        %opts);

Parse a user groupby request, used by native profiling methods.
See parseRequest() for details on syntax of $groupby_request.
Returns a HASH-ref of the form:

 req => $request,    ##-- save request
 x2g => \&x2g,       ##-- group-id extraction code suitable for e.g. DiaColloDB::Relation::Cofreqs::profile(groupby=>\&x2g)
 g2s => \&g2s,       ##-- stringification object suitable for DiaColloDB::Profile::stringify() [CODE,enum, or undef]
 areqs => \@areqs,   ##-- parsed attribute requests ([$attr,$ahaving],...)
 attrs => \@attrs,   ##-- like $coldb->attrs($groupby_request), modulo "having" parts
 titles => \@titles, ##-- like map {$coldb->attrTitle($_)} @attrs

%opts:

 warn  => $level,    ##-- log-level for unknown attributes (default: 'warn')
 relax => $bool,     ##-- allow unsupported attributes (default=0)


=item query2filter

 $cqfilter = $coldb->query2filter($attr,$cquery,%opts);

Converts a CQToken to a CQFilter, for ddc parsing.
%opts:

 logas => $logas,   ##-- log-prefix for warnings

=item parseGroupBy

 ($CQCountKeyExprs,\$CQRestrict,\@CQFilters) = $coldb->parseGroupBy($groupby_string_or_request,%opts);

ddc-mode groupby parsing utility.
%opts:

 date => $date,
 slice => $slice,
 matchid => $matchid,    ##-- default match-id

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Profiling: Generic
=pod

=head2 Profiling: Generic

=over 4

=item profile

 $mprf = $coldb->profile($relation, %opts);

Get a relation profile for selected items as a DiaColloDB::Profile::Multi object.
%opts:

 ##-- selection parameters
 query => $query,           ##-- target request ATTR:REQ...
 date  => $date1,           ##-- string or array or range "MIN-MAX" (inclusive) : default=all
 ##
 ##-- aggregation parameters
 slice   => $slice,         ##-- date slice (default=1, 0 for global profile)
 groupby => $groupby,       ##-- string or array "ATTR1[:HAVING1] ...": default=$coldb->attrs; see groupby() method
 ##
 ##-- scoring and trimming parameters
 eps     => $eps,           ##-- smoothing constant (default=0)
 score   => $func,          ##-- scoring function ("f"|"fm"|"mi"|"ld") : default="f"
 kbest   => $k,             ##-- return only $k best collocates per date (slice) : default=-1:all
 cutoff  => $cutoff,        ##-- minimum score
 global  => $bool,          ##-- trim profiles globally (vs. locally for each date-slice?) (default=0)
 ##
 ##-- profiling and debugging parameters
 strings => $bool,          ##-- do/don't stringify (default=do)
 fill    => $bool,          ##-- if true, returned multi-profile will have null profiles inserted for missing slices

Sets default %opts and wraps $coldb-E<gt>relation($rel)-E<gt>profile($coldb, %opts).

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB: Profiling: Comparison (diff)
=pod

=head2 Profiling: Comparison (diff)

=over 4

=item compare

 $mprf = $coldb->compare($relation, %opts);

Get a relation comparison profile for selected items as a DiaColloDB::Profile::MultiDiff object.
%opts:

 ##-- selection parameters
 (a|b)?query => $query,       ##-- target query as for parseRequest()
 (a|b)?date  => $date1,       ##-- string or array or range "MIN-MAX" (inclusive) : default=all
 ##
 ##-- aggregation parameters
 groupby     => $groupby,     ##-- string or array "ATTR1[:HAVING1] ...": default=$coldb->attrs; see groupby() method
 (a|b)?slice => $slice,       ##-- date slice (default=1, 0 for global profile)
 ##
 ##-- scoring and trimming parameters
 eps     => $eps,             ##-- smoothing constant (default=0)
 score   => $func,            ##-- scoring function ("f"|"fm"|"mi"|"ld") : default="f"
 kbest   => $k,               ##-- return only $k best collocates per date (slice) : default=-1:all
 cutoff  => $cutoff,          ##-- minimum score (UNUSED for comparison profiles)
 global  => $bool,            ##-- trim profiles globally (vs. locally for each date-slice?) (default=0)
 diff    => $diff,            ##-- low-level score-diff operation (diff|adiff|sum|min|max|avg|havg|gavg|lavg); default='adiff'
 ##
 ##-- profiling and debugging parameters
 strings => $bool,            ##-- do/don't stringify (default=do)

Sets default %opts and wraps $coldb-E<gt>relation($rel)-E<gt>compare($coldb, %opts)

=back

=cut

##======================================================================
## Footer
##======================================================================
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2015 by Bryan Jurish

This package is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.

=head1 SEE ALSO

L<dcdb-create.per(1)|dcdb-create.perl>,
L<dcdb-query.perl(1)|dcdb-query.perl>,
L<dcdb-info.perl(1)|dcdb-info.perl>,
L<dcdb-export.perl(1)|dcdb-export.perl>,
L<dcdb-dump.perl(1)|dcdb-dump.perl>,
L<DiaColloDB(3pm)|DiaColloDB>,
L<perl(1)|perl>,
...

=cut
