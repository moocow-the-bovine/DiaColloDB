xsubset2d variant benchmark notes:

IN GENERAL:
+ ptr and iptr tend to outperform ccs variant
  - e.g. "#slice[1] Mann" : ccs=9.8/s (100%), ptr=19.4/s (+98%), iptr=19.2/s (+96%)

+ flat variant is pretty bad on small-to-medium target sets
   - e.g. "#slice[10] Mann"  			     : ccs=9.71/s (100%), flat=8.33/s (-55%)
   - e.g. "#slice[1] $p=NN #has[textClass,/Kinder/]" : ccs=7.84/s (100%), flat=7.84/s (-0%)

+ flat variant outperforms everything else for mid-to-large target sets
  - e.g. "#slice[1] $p=NN"		             : ccs=.092/s (100%), ptr=.088/s (-4%), flat=1.14/s (+141%)
  - e.g. "#slice[10] $p=NN #has[textClass,/Kinder/]" : ccs=2.65/s (100%), ptr=2.75/s (+4%), flat=4.72/s (+ 78%)

+ {ptr,iptr} perform similarly, but iptr sometimes outperforms ptr; the converse is seldom true
  - e.g. "#slice[1] Mann"			     : ptr=19.4/s  (100%), iptr=19.2/s (- 1%)
  - e.g. "#slice[1] $p=NN"			     : ptr=0.088/s (100%), iptr=0.15/s (+74%)
  - e.g. "#slice[10] $p=NN #has[textClass,/Kinder/]" : ptr=2.75/s  (100%), iptr=4.35/s (+58%)
  - interpretation:
    * we have ND=609946 >> NT=109096 (zeit01.d-p)
    * ptr  -> Ndi binary searches on each of Nti ranges (smaller)
    * iptr -> Nti binary searches on each of Ndi ranges (larger)
    * repeated binary searches on the same range are optimized by updating nzi_min
    * range-optimization works (better) for larger ranges, which favors iptr
     

IDEA: "smart" dispatch
+ choose one of (i?)ptr or flat based on target subset size
+ estimate (max) target subset size using (Nti*Ndi): data suggests this is a pretty good indicator
+ data does NOT present us with a totally clear cutoff
  - somewhere between 1e5 and 1e7 for Nnz=18112008 = 1.8e7
  - looks like Nnz/2 (here 9e6) ought to be a safe guess
  

