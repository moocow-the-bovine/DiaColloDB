##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================
use PDL::VectorValued::Dev;
use PDL::CCS::Config;
use PDL;
use strict;

our $VERSION = '0.08.001';
pp_setversion($VERSION);

#$::PP_VERBOSE=1; ##-- PDL::PP debugging

my %ccsConfig = %PDL::CCS::Config::ccsConfig;
my $INDX      = $ccsConfig{INDX_SIG};
my @INT_TYPES = @{$ccsConfig{INT_TYPE_CHRS}};
my $INT_TYPES = join('',@INT_TYPES);

my $CDEBUG = 1;
pp_addhdr(($CDEBUG ? '' : "/*")."#define DIACOLLO_DEBUG 1".($CDEBUG ? '': "*/")."\n");

##------------------------------------------------------
## pm additions
pp_addpm({At=>'Top'},<<'EOPM');

use strict;

=pod

=head1 NAME

DiaColloDB::PDL::Utils - low-level PDL utilities for DiaColloDB

=head1 SYNOPSIS

 use PDL;
 use DiaColloDB::PDL::Utils;

 ##---------------------------------------------------------------------
 ## ... stuff happens

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
#pp_export_nothing();

##------------------------------------------------------
## Includes / defines
pp_addhdr("\n$ccsConfig{INDX_TYPEDEF}\n");
pp_addhdr(<<'EOH');

#include <stdio.h>  /*-- for debugging --*/
#include <string.h> /*-- for memcpy() --*/

#ifdef DIACOLLO_DEBUG
# define DCDEBUG(x) x
#else
# define DCDEBUG(x)
#endif

EOH


##======================================================================
## C Utilities
##======================================================================
# (none)

##======================================================================
## PDL::PP Wrappers
##======================================================================

##--------------------------------------------------------------
## tdm_cof_TC_TYPE : coo+ptr(1)-matrix vs. ptr-vector, output=HASH-ref
##  + TC is one of 't':terms, 'c':cats
##  + TYPE is a piddle type for indices (long, indx)
##  + supports groupby independent TC-attributes only (no term+doc dependence)
##  + from lda/ftdm-kbest.perl inline test _cof3d_pzh()
##  + variants tdm_cof_t_indx(), tdm_cof_t_long()

## undef = tdm_cof_def($tcinfix, $itype)
##  + $tcinfix is one of 't':terms, 'c':cats
##  + $itype is a PDL type or string name
sub tdm_cof_def {
  my ($tcinfix,$itype) = @_;
  my $ihash = (ref($itype)
	       ? $PDL::Types::typehash[ $itype->enum ]
	       : (grep {$_->{ioname} eq $itype} values %PDL::Types::typehash)[0]);
  my $iname = $ihash->{ioname};
  my $ctype = $ihash->{ctype};
  my $stype = $ihash->{ppforcetype};
  my $tcdef = join('', map {$tcinfix eq $_ ? ("#define DIACOLLO_TDM_COF_".uc($_)." 1\n") : ("#undef DIACOLLO_TDM_COF_".uc($_)."\n")} qw(t c));

  ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## tdm_cof_t : code
  my $code = qq{
$tcdef

  $ctype qd,qd1,qc,qval, adnzlo,adnzhi,adnzi,anzi, at,ga,gh;
  PDL_Ushort sliceby,qdate;
  I32 keylen1 = sizeof($ctype);
  I32 keylen  = (\$SIZE(NG)+1)*sizeof($ctype);
  $ctype *keybuf = (${ctype}*)malloc(keylen);
  HV *f1hv  = INT2PTR(HV*, \$COMP(f1Hash));
  HV *f12hv = INT2PTR(HV*, \$COMP(f12Hash));
  SV **svpp;
  UV fval0,fval;

  DCDEBUG(fprintf(stderr,"tdm_cof_${tcinfix}_${iname}(): NnzA=%d, NnzQ=%d, NA=%d, ND=%d, NC=%d, NG=%d, NHaving=%d, slice=%d, mindate=%d, maxdate=%d, keylen=%d\\n", \$SIZE(NnzA), \$SIZE(NnzQ), \$SIZE(NA), \$SIZE(ND), \$SIZE(NC), \$SIZE(NG), \$SIZE(NHaving), \$dateslice(), \$mindate(), \$maxdate(), keylen); fflush(stderr);)
}.q{
  hv_clear(f12hv);

  threadloop %{
    sliceby           = $dateslice();
    keybuf[$SIZE(NG)] = sliceby;

    /*-- guts: compute co-frequencies cofreq(w,v|d) = min{f(w,d),f(v,d)} in f12hv --*/
    //DCDEBUG(fprintf(stderr,"tdm_cof(): loop\n"); fflush(stderr);)
    loop (NnzQ) %{
      qval = $qvals();
      qd   = $qdocs();
      qd1  = qd+1;

      //-- setup output date component, checking target range
      qc    = $d2c(ND=>qd);
      qdate = $c2date(NC=>qc);
      if (qdate < $mindate() || qdate > $maxdate()) continue;
      if (sliceby != 0) {
        keybuf[$SIZE(NG)] = sliceby * (qdate/sliceby);
      }

      //-- track f1 frequency (by slice)
      svpp = hv_fetch(f1hv, (char*)(keybuf+$SIZE(NG)), keylen1, TRUE);
      if (SvOK(*svpp)) {
        fval0 = SvUV(*svpp);
	sv_setuv(*svpp, fval0+(UV)qval);
      } else {
        sv_setuv(*svpp, (UV)qval);
      }

#ifdef DIACOLLO_TDM_COF_C
      //-- check HAVING restrictions (groupby-cats mode)
      if ($SIZE(NHaving) > 0) {
        $LB('qc', '$ghaving(NHaving=>$_)', 0,'$SIZE(NHaving)', 'gh');
        if (gh >= $SIZE(NHaving) || $ghaving(NHaving=>gh) != qc) continue;
      }

      //-- setup output output hash key (groupby-cats mode)
      loop (NG) %{
        ga = $groupby();
	keybuf[NG] = $xattrs(NA=>ga,NX=>qc);
      %}

      //-- setup item2 count (groupby-cats mode)
      svpp = hv_fetch(f12hv, (char*)keybuf, keylen, TRUE);
      if (SvOK(*svpp)) {
        fval = SvUV(*svpp);
      } else {
        fval = 0;
      }
#endif

      //-- collect co-occurence frequencies by document
      adnzlo = $aptr1(NDplus1=>qd);
      adnzhi = $aptr1(NDplus1=>qd1);
      for (adnzi=adnzlo; adnzi < adnzhi; ++adnzi) {
        anzi   = $apix1(NnzA=>adnzi);
 	at     = $awhich(Ndims=>0,NnzA=>anzi);

#ifdef DIACOLLO_TDM_COF_T
        //-- check HAVING restrictions (groupby-terms mode)
        if ($SIZE(NHaving) > 0) {
	  $LB('at', '$ghaving(NHaving=>$_)', 0,'$SIZE(NHaving)', 'gh');
          if (gh >= $SIZE(NHaving) || $ghaving(NHaving=>gh) != at) continue;
        }

	//-- setup output output hash key (groupby-terms mode)
	loop (NG) %{
	  ga = $groupby();
	  keybuf[NG] = $xattrs(NA=>ga,NX=>at);
	%}

        //-- set or update f12 hash value
        fval = (UV)(qval < $avals(NnzA1=>anzi) ? qval : $avals(NnzA1=>anzi));
	svpp = hv_fetch(f12hv, (char*)keybuf, keylen, TRUE);
        if (SvOK(*svpp)) {
	  fval0 = SvUV(*svpp);
	  sv_setuv(*svpp, fval0+fval);
        } else {
          sv_setuv(*svpp, fval);
        }
#endif
#ifdef DIACOLLO_TDM_COF_C
        fval += (UV)(qval < $avals(NnzA1=>anzi) ? qval : $avals(NnzA1=>anzi));
#endif
      }
#ifdef DIACOLLO_TDM_COF_C
      sv_setuv(*svpp, fval);
#endif
    %}
  %}
  if (keybuf) free(keybuf);
};

  ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## tdm_cof : ppdef
  my $INDX = $stype;
  vvpp_def("diacollo_tdm_cof_${tcinfix}_${iname}",
	 Pars => join("\n    ",
		      '',
		      "$INDX awhich(Ndims,NnzA);",	##-- a() ~ tdm: logical (T,D) with ptr(1) : $vs->{tdm}->_whichND
		      "$INDX aptr1(NDplus1);",		##-- a(): ptr(1) : $vs->{ptr1}
		      "$INDX apix1(NnzA);",		##-- a(): sort-indices over NNzA for ptr(1) : $vs->{pix1}
		      "      avals(NnzA1);",		##-- a(): nonzeroes : $vs->{tdm}->_vals
		      ##
		      "$INDX xattrs(NA,NX);",		##-- attrs() ~ (term|cat) attributes
		      "$INDX d2c(ND);",               	##-- d2c(): doc->cat map : $vs->{d2c}
		      ##
		      "ushort c2date(NC);",             ##-- c2date(): cat->date map : $vs->{c2date}
		      "ushort dateslice();",            ##-- slice value
		      "ushort mindate();",              ##-- minimum date (inlusive)
		      "ushort maxdate();",		##-- maximum date (inclusive)
		      ##
		      "$INDX qdocs(NnzQ);",		##-- query vector: nz doc-indices (item1)
		      "      qvals(NnzQ);",		##-- query vector: nz doc-frequencies (item1)
		      ##
		      "$INDX groupby(NG);",		##-- attribute indices over NA for groupby()
		      "$INDX ghaving(NHaving);",	##-- admissible item2 (term|cat)-ids, or empty for all
		      ''
		     ),
	 OtherPars => join("\n    ",
			   'IV f1Hash;',		##-- output hash, ( pack($pack_ix, $slice) => $f1, ... )
			   'IV f12Hash;',		##-- output hash, ( pack($pack_ix, $tvals($groupby(),($ti2)), $slice) => $f12, ... )
			  ),
	 Code => $code,
	);
}
foreach my $tcinfix (qw(t c)) {
  tdm_cof_def($tcinfix,'long');
  tdm_cof_def($tcinfix,'indx') if (PDL->can('indx'));
}

##--------------------------------------------------------------
## tym_gf_t_TYPE : item2 freqs, tym=coo, output=HASH-ref (groupby terms only)
##  + from lda/ftdm-kbest.perl inline test _f2_scan()
##  + variants tym_gf_t_indx(), tym_gf_t_long()

sub tym_gf_t_def {
  my $itype = shift;
  my $ihash = (ref($itype)
	       ? $PDL::Types::typehash[ $itype->enum ]
	       : (grep {$_->{ioname} eq $itype} values %PDL::Types::typehash)[0]);
  my $iname = $ihash->{ioname};
  my $ctype = $ihash->{ctype};
  my $stype = $ihash->{ppforcetype};

  ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## tym_gf_t : code
  my $code = qq{
  $ctype t2,t2nxt, anzi_min=0,anzi_max=\$SIZE(NnzA),anzi, ga;
  PDL_Ushort sliceby,adate;
  I32 keylen = (\$SIZE(NG)+1)*sizeof($ctype);
  $ctype *keybuf = (${ctype}*)malloc(keylen);
  HV *f12hv = \$COMP(f12Hash) ? INT2PTR(HV*, \$COMP(f12Hash)) : NULL;
  HV *f2hv  = INT2PTR(HV*, \$COMP(f2Hash));
  SV **svpp;
  UV f2val0, f2val;

  DCDEBUG(fprintf(stderr,"tym_gf_${iname}(): NnzA=%d, NT2=%d, NA=%d, NG=%d, slice=%d, mindate=%d, maxdate=%d, keylen=%d, f12hv=%p, f2hv=%p\\n", \$SIZE(NnzA), \$SIZE(NT2), \$SIZE(NA), \$SIZE(NG), \$dateslice(), \$mindate(), \$maxdate(), keylen, f12hv, f2hv); fflush(stderr);)
}.q{
  hv_clear(f2hv);

  sliceby           = $dateslice();
  keybuf[$SIZE(NG)] = sliceby;

  /*-- guts: compute independent item2 frequencies in f2hv --*/
  DCDEBUG(fprintf(stderr,"tym_gf(): loop(NT2)\n"); fflush(stderr);)
  loop (NT2) %{
    t2    = $terms2();
    t2nxt = t2+1;

    //-- setup output hash key
    loop (NG) %{
      ga = $groupby();
      keybuf[NG] = $tattrs(NA=>ga,NT=>t2);
    %}

    $LB('t2', '$awhich(Ndims=>0,NnzA=>$_)', 'anzi_min','anzi_max', 'anzi');
    for ( ; anzi < $SIZE(NnzA) && $awhich(Ndims=>0,NnzA=>anzi) == t2; ++anzi) {

      //-- setup output date component, checking date-range
      adate = $awhich(Ndims=>1,NnzA=>anzi);
      if (adate < $mindate() || adate > $maxdate()) continue;
      if (sliceby != 0) {
        keybuf[$SIZE(NG)] = sliceby * (adate/sliceby);
      }

      //-- ignore possible keys not in f12hv
      if (f12hv && !hv_exists(f12hv, (char*)keybuf, keylen))
        continue;

      //-- set or update output hash value
      f2val = $avals(NnzA1=>anzi);
      svpp  = hv_fetch(f2hv, (char*)keybuf, keylen, TRUE);
      if (SvOK(*svpp)) {
        f2val0 = SvUV(*svpp);
	sv_setuv(*svpp, f2val0+f2val);
      }
      else {
        sv_setuv(*svpp, f2val);
      }
    }
    anzi_min = anzi;
  %}
  if (keybuf) free(keybuf);
};

  ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## tym_gf : ppdef
  my $INDX = $stype;
  vvpp_def("diacollo_tym_gf_t_${iname}",
	   Pars => join("\n    ",
		      '',
			"$INDX awhich(Ndims,NnzA);",	##-- a() ~ tym: logical (T,Y) with ptr(0) : $vs->{tym}->_whichND
			"      avals(NnzA1);",		##-- a(): nonzeroes : $vs->{tym}->_vals
			##
			"$INDX tattrs(NA,NT);",		##-- tattrs() ~ term attributes
			##
			"ushort dateslice();",		##-- slice value
			"ushort mindate();",		##-- minimum date (inlusive)
			"ushort maxdate();",		##-- maximum date (inclusive)
			##
			"$INDX terms2(NT2);",		##-- item2 keys: term IDs (sorted)
			"$INDX groupby(NG);",		##-- attribute indices over NA for groupby()
			''
		       ),
	   OtherPars => 'IV f12Hash; IV f2Hash;',	##-- in,out hashes, ( pack($pack_ix, $tvals($groupby(),($ti2)), $slice) => $f12, ... )
	   Code => $code,
	);
}
tym_gf_t_def('long');
tym_gf_t_def('indx') if (PDL->can('indx'));

##--------------------------------------------------------------
## gf_c_TYPE : item2 freqs, tym=coo, output=HASH-ref (groupby catse only)
##  + variants gf_c_indx(), gf_c_long()

sub gf_c_def {
  my $itype = shift;
  my $ihash = (ref($itype)
	       ? $PDL::Types::typehash[ $itype->enum ]
	       : (grep {$_->{ioname} eq $itype} values %PDL::Types::typehash)[0]);
  my $iname = $ihash->{ioname};
  my $ctype = $ihash->{ctype};
  my $stype = $ihash->{ppforcetype};

  ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## tym_gf_t : code
  my $code = qq{
  $ctype c2, ga;
  PDL_Ushort sliceby,cdate;
  I32 keylen = (\$SIZE(NG)+1)*sizeof($ctype);
  $ctype *keybuf = (${ctype}*)malloc(keylen);
  HV *f12hv = \$COMP(f12Hash) ? INT2PTR(HV*, \$COMP(f12Hash)) : NULL;
  HV *f2hv  = INT2PTR(HV*, \$COMP(f2Hash));
  SV **svpp;
  UV f2val0, f2val;

  DCDEBUG(fprintf(stderr,"gf_c_${iname}(): NC=%d, NC2=%d, NA=%d, NG=%d, slice=%d, keylen=%d, f12hv=%p, f2hv=%p\\n", \$SIZE(NC), \$SIZE(NC2), \$SIZE(NA), \$SIZE(NG), \$dateslice(), keylen, f12hv, f2hv); fflush(stderr);)
}.q{
  hv_clear(f2hv);

  sliceby           = $dateslice();
  keybuf[$SIZE(NG)] = sliceby;

  /*-- guts: compute independent item2 frequencies in f2hv --*/
  //DCDEBUG(fprintf(stderr,"gf_c(): loop(NC2)\n"); fflush(stderr);)
  loop (NC2) %{
    c2 = $cats2();

    //-- setup output hash key
    loop (NG) %{
      ga = $groupby();
      keybuf[NG] = $cattrs(NA=>ga,NC=>c2);
    %}

    //-- setup output date component
    cdate = $c2date(NC=>c2);
    if (sliceby != 0) {
      keybuf[$SIZE(NG)] = sliceby * (cdate/sliceby);
    }

    //-- ignore possible keys not in f12hv
    if (f12hv && !hv_exists(f12hv, (char*)keybuf, keylen))
      continue;

    //-- set or update output hash value
    f2val = $cf(NC=>c2);
    svpp  = hv_fetch(f2hv, (char*)keybuf, keylen, TRUE);
    if (SvOK(*svpp)) {
      f2val0 = SvUV(*svpp);
      sv_setuv(*svpp, f2val0+f2val);
    } else {
      sv_setuv(*svpp, f2val);
    }
  %}
  if (keybuf) free(keybuf);
};

  ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## gf_c : ppdef
  my $INDX = $stype;
  vvpp_def("diacollo_gf_c_${iname}",
	   Pars => join("\n    ",
		      '',
			"cf(NC);",			##-- cf() ~ total cat frequencies
			##
			"$INDX cattrs(NA,NC);",		##-- tattrs() ~ cat attributes
			"ushort c2date(NC);",           ##-- c2date(): cat->date map : $vs->{c2date}
			"ushort dateslice();",          ##-- slice value
			##
			"$INDX cats2(NC2);",		##-- item2 keys: cats-IDs (sorted)
			"$INDX groupby(NG);",		##-- meta-attribute indices over NA for groupby()
			''
		       ),
	   OtherPars => 'IV f12Hash; IV f2Hash;',	##-- in,out hashes, ( pack($pack_ix, $tvals($groupby(),($ti2)), $slice) => $f12, ... )
	   Code => $code,
	);
}
gf_c_def('long');
gf_c_def('indx') if (PDL->can('indx'));

##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions: footer
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head2 Copyright Policy

Copyright (C) 2016, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl)

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
